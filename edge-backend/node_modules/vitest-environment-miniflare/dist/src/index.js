// packages/vitest-environment-miniflare/src/index.ts
import stream from "stream/web";
import { QueueBroker } from "@miniflare/queues";
import { VMScriptRunner } from "@miniflare/runner-vm";
import {
  ExecutionContext,
  StackedMemoryStorageFactory,
  createMiniflareEnvironment
} from "@miniflare/shared-test-environment";

// node_modules/@vitest/runner/dist/utils.js
function createChainable(keys, fn) {
  function create(context) {
    const chain2 = function(...args) {
      return fn.apply(context, args);
    };
    Object.assign(chain2, fn);
    chain2.withContext = () => chain2.bind(context);
    chain2.setContext = (key, value) => {
      context[key] = value;
    };
    chain2.mergeContext = (ctx) => {
      Object.assign(context, ctx);
    };
    for (const key of keys) {
      Object.defineProperty(chain2, key, {
        get() {
          return create({ ...context, [key]: true });
        }
      });
    }
    return chain2;
  }
  const chain = create({});
  chain.fn = fn;
  return chain;
}

// packages/vitest-environment-miniflare/src/index.ts
var scriptRunner = new VMScriptRunner();
var queueBroker = new QueueBroker();
function setupIsolatedStorage(vitestImpl, storageFactory) {
  vitestImpl.beforeEach(() => storageFactory.push());
  vitestImpl.afterEach(() => storageFactory.pop());
  const wrappedDescribeFn = function(name, factory) {
    if (typeof factory !== "function") {
      return vitestImpl.describe.fn.call(this, name, factory);
    }
    const newFactory = (test) => {
      vitestImpl.beforeAll(() => storageFactory.push());
      vitestImpl.afterAll(() => storageFactory.pop());
      return factory(test);
    };
    return vitestImpl.describe.fn.call(this, name, newFactory);
  };
  const wrappedDescribe = wrappedDescribeFn;
  wrappedDescribe.each = vitestImpl.describe.each;
  wrappedDescribe.skipIf = (condition) => condition ? wrappedChainable.skip : wrappedChainable;
  wrappedDescribe.runIf = (condition) => condition ? wrappedChainable : wrappedChainable.skip;
  const wrappedChainable = createChainable(["concurrent", "shuffle", "skip", "only", "todo"], wrappedDescribe);
  return wrappedChainable;
}
var src_default = {
  name: "miniflare",
  transformMode: "ssr",
  async setup(global, options) {
    const vitestImpl = await import("vitest");
    globalThis.ReadableStream = stream.ReadableStream;
    globalThis.WritableStream = stream.WritableStream;
    globalThis.TransformStream = stream.TransformStream;
    await import("undici/lib/fetch/index.js");
    const storageFactory = new StackedMemoryStorageFactory();
    const [mf, mfGlobalScope] = await createMiniflareEnvironment({ storageFactory, scriptRunner, queueBroker }, options, { ExecutionContext });
    mfGlobalScope.setupMiniflareIsolatedStorage = () => setupIsolatedStorage(vitestImpl, storageFactory);
    const crypto = mfGlobalScope.crypto;
    delete mfGlobalScope.crypto;
    Object.defineProperty(global, "crypto", { get: () => crypto });
    const navigator = mfGlobalScope.navigator;
    delete mfGlobalScope.navigator;
    Object.defineProperty(global, "navigator", { get: () => navigator });
    const keys = Object.keys(mfGlobalScope);
    const originals = new Map();
    for (const key of keys) {
      if (key in global)
        originals.set(key, global[key]);
    }
    Object.assign(global, mfGlobalScope);
    return {
      teardown(global2) {
        for (const key of keys) {
          if (originals.has(key)) {
            global2[key] = originals.get(key);
          } else {
            delete global2[key];
          }
        }
        return mf.dispose();
      }
    };
  }
};
export {
  src_default as default
};
//# sourceMappingURL=index.js.map
